{
  "bundles": [
    {
      "id": "1",
      "title": "NFT Creation & IP Registration Bundle",
      "description": "Complete toolkit for creating NFTs and registering intellectual property on Story Protocol. This bundle provides everything you need to create, mint, and register your IP assets securely.",
      "tags": ["Story Protocol", "NFT", "IP", "Blockchain"],
      "icon": "ğŸ­",
      "category": "Story Protocol",
      "usageCount": 987,
      "rating": 4.9,
      "price": 50,
      "owner": "0x1234567890123456789012345678901234567890",
      "approved": true,
      "active": true,
      "mcps": ["1", "3", "4"],
      "revenue": 49350,
      "steps": [
        {
          "name": "Create SPG NFT Collection",
          "description": "Set up your NFT collection on Story Protocol for IP registration",
          "mcpId": "3"
        },
        {
          "name": "Upload Assets to IPFS",
          "description": "Store your creative assets on decentralized storage",
          "mcpId": "4"
        },
        {
          "name": "Mint NFT with IP Terms",
          "description": "Create an NFT with IP licensing terms and register it on Story Protocol",
          "mcpId": "3"
        }
      ],
      "codeExamples": {
        "typescript": "// Step 1: Create SPG NFT Collection\nimport { zeroAddress } from 'viem'\nimport { client } from '../config'\n\nconst createCollection = async () => {\n  const newCollection = await client.nftClient.createNFTCollection({\n    name: 'My Story NFTs',\n    symbol: 'STORY',\n    isPublicMinting: true,\n    mintOpen: true,\n    mintFeeRecipient: zeroAddress,\n    contractURI: '',\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('New collection created:', {\n    'SPG NFT Contract Address': newCollection.spgNftContract,\n    'Transaction Hash': newCollection.txHash,\n  })\n  \n  return newCollection.spgNftContract\n}\n\n// Step 2: Upload Assets to IPFS\nimport { PinataSDK } from 'pinata-web3'\n\nconst uploadToIPFS = async (metadata) => {\n  const pinata = new PinataSDK({\n    pinataJwt: process.env.PINATA_JWT,\n  })\n  \n  const { IpfsHash } = await pinata.upload.json(metadata)\n  return IpfsHash\n}\n\n// Step 3: Mint NFT with IP Terms\nimport { Address } from 'viem'\n\nconst mintNFTWithIPTerms = async (spgNftContract, ipfsHash, ownerAddress) => {\n  const uri = `ipfs://${ipfsHash}`\n  \n  const mintResult = await client.ipAssetClient.mintAndRegisterIpAssetWithPilTerms({\n    to: ownerAddress,\n    tokenURI: uri,\n    spgNftContract: spgNftContract,\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('NFT minted with IP registration:', {\n    'IP Asset ID': mintResult.ipAssetId,\n    'Transaction Hash': mintResult.txHash\n  })\n  \n  return mintResult.ipAssetId\n}\n\n// Complete flow\nconst createIPRegisteredNFT = async (metadata, ownerAddress) => {\n  // Step 1: Create collection\n  const spgNftContract = await createCollection()\n  \n  // Step 2: Upload metadata to IPFS\n  const ipfsHash = await uploadToIPFS(metadata)\n  \n  // Step 3: Mint NFT with IP terms\n  const ipAssetId = await mintNFTWithIPTerms(spgNftContract, ipfsHash, ownerAddress)\n  \n  return {\n    spgNftContract,\n    ipfsHash,\n    ipAssetId\n  }\n}",
        "python": "# Step 1: Create SPG NFT Collection\nfrom web3 import Web3\nfrom story_protocol import Client\n\ndef create_collection():\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    new_collection = client.nft_client.create_nft_collection(\n        name='My Story NFTs',\n        symbol='STORY',\n        is_public_minting=True,\n        mint_open=True,\n        mint_fee_recipient=Web3.toChecksumAddress('0x0000000000000000000000000000000000000000'),\n        contract_uri='',\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('New collection created:', {\n        'SPG NFT Contract Address': new_collection.spg_nft_contract,\n        'Transaction Hash': new_collection.tx_hash\n    })\n    \n    return new_collection.spg_nft_contract\n\n# Step 2: Upload Assets to IPFS\nfrom pinata_web3 import PinataSDK\nimport os\n\ndef upload_to_ipfs(metadata):\n    pinata = PinataSDK(pinata_jwt=os.environ.get('PINATA_JWT'))\n    \n    result = pinata.upload.json(metadata)\n    return result['IpfsHash']\n\n# Step 3: Mint NFT with IP Terms\ndef mint_nft_with_ip_terms(spg_nft_contract, ipfs_hash, owner_address):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    uri = f'ipfs://{ipfs_hash}'\n    \n    mint_result = client.ip_asset_client.mint_and_register_ip_asset_with_pil_terms(\n        to=owner_address,\n        token_uri=uri,\n        spg_nft_contract=spg_nft_contract,\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('NFT minted with IP registration:', {\n        'IP Asset ID': mint_result.ip_asset_id,\n        'Transaction Hash': mint_result.tx_hash\n    })\n    \n    return mint_result.ip_asset_id\n\n# Complete flow\ndef create_ip_registered_nft(metadata, owner_address):\n    # Step 1: Create collection\n    spg_nft_contract = create_collection()\n    \n    # Step 2: Upload metadata to IPFS\n    ipfs_hash = upload_to_ipfs(metadata)\n    \n    # Step 3: Mint NFT with IP terms\n    ip_asset_id = mint_nft_with_ip_terms(spg_nft_contract, ipfs_hash, owner_address)\n    \n    return {\n        'spg_nft_contract': spg_nft_contract,\n        'ipfs_hash': ipfs_hash,\n        'ip_asset_id': ip_asset_id\n    }",
        "shell": "# This is a simplified example of the workflow\n# In practice, you would need to use multiple commands\n\n# Step 1: Create SPG NFT Collection\ncurl -X POST https://api.storyprotocol.xyz/v1/nft/collections \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"My Story NFTs\",\n    \"symbol\": \"STORY\",\n    \"isPublicMinting\": true,\n    \"mintOpen\": true,\n    \"mintFeeRecipient\": \"0x0000000000000000000000000000000000000000\",\n    \"contractURI\": \"\",\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'\n\n# Step 2: Upload Assets to IPFS\ncurl -X POST https://api.pinata.cloud/pinning/pinJSONToIPFS \\\n  -H \"Authorization: Bearer your-pinata-jwt\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"name\": \"My NFT\",\n    \"description\": \"This is my NFT with IP rights\",\n    \"image\": \"ipfs://QmImage...\"\n  }'\n\n# Step 3: Mint NFT with IP Terms\ncurl -X POST https://api.storyprotocol.xyz/v1/ip-assets/mint-and-register \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"to\": \"0xYourAddress...\",\n    \"tokenURI\": \"ipfs://QmYourIPFSHash...\",\n    \"spgNftContract\": \"0xYourSPGContractAddress...\",\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'"
      }
    },
    {
      "id": "2",
      "title": "Licensing & Royalty Management Bundle",
      "description": "Complete toolkit for managing intellectual property licenses and royalties on Story Protocol. This bundle simplifies the process of creating, enforcing, and monetizing IP licenses.",
      "tags": ["Story Protocol", "Licensing", "Royalties", "IP"],
      "icon": "ğŸ“œ",
      "category": "Story Protocol",
      "usageCount": 731,
      "rating": 4.8,
      "price": 45,
      "owner": "0x1234567890123456789012345678901234567890",
      "approved": true,
      "active": true,
      "mcps": ["3", "6"],
      "revenue": 32895,
      "steps": [
        {
          "name": "Create License Terms",
          "description": "Define your IP licensing terms and conditions",
          "mcpId": "3"
        },
        {
          "name": "Setup Royalty Distribution",
          "description": "Configure royalty splits and payment distribution",
          "mcpId": "6"
        },
        {
          "name": "Monitor License Usage",
          "description": "Track and enforce licensing agreements",
          "mcpId": "6"
        }
      ],
      "codeExamples": {
        "typescript": "// Step 1: Create License Terms\nimport { client } from '../config'\n\nconst createLicenseTerms = async (ipAssetId) => {\n  const licenseTerms = await client.licensingClient.createLicenseTerms({\n    ipAssetId,\n    commercialUse: true,\n    commercialAttribution: true,\n    commercializerChecker: '0x1234567890123456789012345678901234567890',\n    commercialRevShare: 500, // 5%\n    derivativesAllowed: true,\n    derivativesAttribution: true,\n    derivativesApproval: false,\n    derivativesReciprocal: true,\n    territories: [], // Empty means worldwide\n    distributionChannels: [], // Empty means all channels\n    contentRestrictions: [],\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('License terms created:', {\n    'License Terms ID': licenseTerms.licenseTermsId,\n    'Transaction Hash': licenseTerms.txHash\n  })\n  \n  return licenseTerms.licenseTermsId\n}\n\n// Step 2: Setup Royalty Distribution\nconst setupRoyaltyDistribution = async (ipAssetId) => {\n  const royaltySplits = await client.royaltyClient.createRoyaltySplits({\n    ipAssetId,\n    splits: [\n      { recipient: '0x1234567890123456789012345678901234567890', percentage: 6000 }, // 60%\n      { recipient: '0x2345678901234567890123456789012345678901', percentage: 4000 }  // 40%\n    ],\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('Royalty splits created:', {\n    'Royalty Config ID': royaltySplits.royaltyConfigId,\n    'Transaction Hash': royaltySplits.txHash\n  })\n  \n  return royaltySplits.royaltyConfigId\n}\n\n// Step 3: Monitor License Usage\nconst monitorLicenseUsage = async (licenseTermsId) => {\n  const activeUsage = await client.licensingClient.getActiveLicenses({\n    licenseTermsId\n  })\n  \n  console.log('Active licenses:', activeUsage.licenses.length)\n  \n  const revenues = await client.royaltyClient.getRoyaltyRevenues({\n    licenseTermsId\n  })\n  \n  console.log('Total royalties collected:', revenues.total)\n  console.log('Recent transactions:', revenues.transactions)\n  \n  return {\n    activeUsage: activeUsage.licenses.length,\n    totalRevenues: revenues.total\n  }\n}\n\n// Complete flow\nconst manageLicensingAndRoyalties = async (ipAssetId) => {\n  // Step 1: Create license terms\n  const licenseTermsId = await createLicenseTerms(ipAssetId)\n  \n  // Step 2: Setup royalty distribution\n  const royaltyConfigId = await setupRoyaltyDistribution(ipAssetId)\n  \n  // Step 3: Monitor license usage\n  const usageStats = await monitorLicenseUsage(licenseTermsId)\n  \n  return {\n    licenseTermsId,\n    royaltyConfigId,\n    usageStats\n  }\n}",
        "python": "# Step 1: Create License Terms\nfrom story_protocol import Client\n\ndef create_license_terms(ip_asset_id):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    license_terms = client.licensing_client.create_license_terms(\n        ip_asset_id=ip_asset_id,\n        commercial_use=True,\n        commercial_attribution=True,\n        commercializer_checker='0x1234567890123456789012345678901234567890',\n        commercial_rev_share=500,  # 5%\n        derivatives_allowed=True,\n        derivatives_attribution=True,\n        derivatives_approval=False,\n        derivatives_reciprocal=True,\n        territories=[],  # Empty means worldwide\n        distribution_channels=[],  # Empty means all channels\n        content_restrictions=[],\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('License terms created:', {\n        'License Terms ID': license_terms.license_terms_id,\n        'Transaction Hash': license_terms.tx_hash\n    })\n    \n    return license_terms.license_terms_id\n\n# Step 2: Setup Royalty Distribution\ndef setup_royalty_distribution(ip_asset_id):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    royalty_splits = client.royalty_client.create_royalty_splits(\n        ip_asset_id=ip_asset_id,\n        splits=[\n            {'recipient': '0x1234567890123456789012345678901234567890', 'percentage': 6000},  # 60%\n            {'recipient': '0x2345678901234567890123456789012345678901', 'percentage': 4000}   # 40%\n        ],\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('Royalty splits created:', {\n        'Royalty Config ID': royalty_splits.royalty_config_id,\n        'Transaction Hash': royalty_splits.tx_hash\n    })\n    \n    return royalty_splits.royalty_config_id\n\n# Step 3: Monitor License Usage\ndef monitor_license_usage(license_terms_id):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    active_usage = client.licensing_client.get_active_licenses(\n        license_terms_id=license_terms_id\n    )\n    \n    print('Active licenses:', len(active_usage.licenses))\n    \n    revenues = client.royalty_client.get_royalty_revenues(\n        license_terms_id=license_terms_id\n    )\n    \n    print('Total royalties collected:', revenues.total)\n    print('Recent transactions:', revenues.transactions)\n    \n    return {\n        'active_usage': len(active_usage.licenses),\n        'total_revenues': revenues.total\n    }\n\n# Complete flow\ndef manage_licensing_and_royalties(ip_asset_id):\n    # Step 1: Create license terms\n    license_terms_id = create_license_terms(ip_asset_id)\n    \n    # Step 2: Setup royalty distribution\n    royalty_config_id = setup_royalty_distribution(ip_asset_id)\n    \n    # Step 3: Monitor license usage\n    usage_stats = monitor_license_usage(license_terms_id)\n    \n    return {\n        'license_terms_id': license_terms_id,\n        'royalty_config_id': royalty_config_id,\n        'usage_stats': usage_stats\n    }",
        "shell": "# This is a simplified example of the workflow\n# In practice, you would need to use multiple commands\n\n# Step 1: Create License Terms\ncurl -X POST https://api.storyprotocol.xyz/v1/licensing/terms \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"ipAssetId\": \"your-ip-asset-id\",\n    \"commercialUse\": true,\n    \"commercialAttribution\": true,\n    \"commercializerChecker\": \"0x1234567890123456789012345678901234567890\",\n    \"commercialRevShare\": 500,\n    \"derivativesAllowed\": true,\n    \"derivativesAttribution\": true,\n    \"derivativesApproval\": false,\n    \"derivativesReciprocal\": true,\n    \"territories\": [],\n    \"distributionChannels\": [],\n    \"contentRestrictions\": [],\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'\n\n# Step 2: Setup Royalty Distribution\ncurl -X POST https://api.storyprotocol.xyz/v1/royalties/splits \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"ipAssetId\": \"your-ip-asset-id\",\n    \"splits\": [\n      { \"recipient\": \"0x1234567890123456789012345678901234567890\", \"percentage\": 6000 },\n      { \"recipient\": \"0x2345678901234567890123456789012345678901\", \"percentage\": 4000 }\n    ],\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'\n\n# Step 3: Monitor License Usage\ncurl -X GET https://api.storyprotocol.xyz/v1/licensing/terms/your-license-terms-id/licenses \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\"\n\ncurl -X GET https://api.storyprotocol.xyz/v1/royalties/terms/your-license-terms-id/revenues \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\""
      }
    },
    {
      "id": "3",
      "title": "Derivative Works & Remixing Bundle",
      "description": "Complete toolkit for creating and managing derivative works on Story Protocol. This bundle provides tools for remixing, attribution, and managing rights for derivative content.",
      "tags": ["Story Protocol", "Derivatives", "Remixing", "Attribution"],
      "icon": "ğŸ”„",
      "category": "Story Protocol",
      "usageCount": 528,
      "rating": 4.7,
      "price": 55,
      "owner": "0x1234567890123456789012345678901234567890",
      "approved": true,
      "active": true,
      "mcps": ["1", "2", "3", "4"],
      "revenue": 29040,
      "steps": [
        {
          "name": "Find Remixable Assets",
          "description": "Discover IP assets that allow derivatives",
          "mcpId": "2"
        },
        {
          "name": "Create Derivative Work",
          "description": "Create and upload your derivative content",
          "mcpId": "1"
        },
        {
          "name": "Register Relationship",
          "description": "Register the derivative relationship on Story Protocol",
          "mcpId": "3"
        },
        {
          "name": "Setup Attribution",
          "description": "Configure proper attribution for original creators",
          "mcpId": "4"
        }
      ],
      "codeExamples": {
        "typescript": "// Step 1: Find Remixable Assets\nimport { client } from '../config'\n\nconst findRemixableAssets = async (category, limit = 10) => {\n  const remixableAssets = await client.ipAssetClient.searchIpAssets({\n    filters: {\n      categories: [category],\n      allowsDerivatives: true\n    },\n    limit\n  })\n  \n  console.log(`Found ${remixableAssets.total} remixable assets in category '${category}'`)\n  \n  return remixableAssets.assets\n}\n\n// Step 2: Create Derivative Work\nimport { PinataSDK } from 'pinata-web3'\n\nconst createDerivativeContent = async (originalAssetId, derivativeMetadata) => {\n  // Add attribution to metadata\n  const enrichedMetadata = {\n    ...derivativeMetadata,\n    attribution: {\n      originalAssetId,\n      relationship: 'derivative'\n    }\n  }\n  \n  // Upload to IPFS\n  const pinata = new PinataSDK({\n    pinataJwt: process.env.PINATA_JWT,\n  })\n  \n  const { IpfsHash } = await pinata.upload.json(enrichedMetadata)\n  \n  console.log('Derivative content created and uploaded to IPFS:', IpfsHash)\n  \n  return IpfsHash\n}\n\n// Step 3: Register Relationship\nconst registerDerivativeRelationship = async (originalAssetId, derivativeAssetId) => {\n  const relationship = await client.ipAssetClient.registerRelationship({\n    parentIpAssetId: originalAssetId,\n    childIpAssetId: derivativeAssetId,\n    relationType: 'DERIVATIVE',\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('Derivative relationship registered:', {\n    'Relationship ID': relationship.relationshipId,\n    'Transaction Hash': relationship.txHash\n  })\n  \n  return relationship.relationshipId\n}\n\n// Step 4: Setup Attribution\nconst setupAttribution = async (originalAssetId, derivativeAssetId, attributionText) => {\n  const attribution = await client.attributionClient.setAttribution({\n    ipAssetId: derivativeAssetId,\n    attributesIpAssetId: originalAssetId,\n    attributionText,\n    txOptions: { waitForTransaction: true },\n  })\n  \n  console.log('Attribution configured:', {\n    'Attribution ID': attribution.attributionId,\n    'Transaction Hash': attribution.txHash\n  })\n  \n  return attribution.attributionId\n}\n\n// Complete flow\nconst createDerivativeWork = async (category, derivativeMetadata, attributionText) => {\n  // Step 1: Find remixable assets\n  const remixableAssets = await findRemixableAssets(category)\n  const originalAssetId = remixableAssets[0].id // Select first asset for this example\n  \n  // Step 2: Create derivative content\n  const ipfsHash = await createDerivativeContent(originalAssetId, derivativeMetadata)\n  \n  // Create the derivative NFT\n  const mintResult = await client.ipAssetClient.mintAndRegisterIpAsset({\n    to: process.env.WALLET_ADDRESS,\n    tokenURI: `ipfs://${ipfsHash}`,\n    txOptions: { waitForTransaction: true },\n  })\n  \n  const derivativeAssetId = mintResult.ipAssetId\n  \n  // Step 3: Register relationship\n  const relationshipId = await registerDerivativeRelationship(originalAssetId, derivativeAssetId)\n  \n  // Step 4: Setup attribution\n  const attributionId = await setupAttribution(originalAssetId, derivativeAssetId, attributionText)\n  \n  return {\n    originalAssetId,\n    derivativeAssetId,\n    ipfsHash,\n    relationshipId,\n    attributionId\n  }\n}",
        "python": "# Step 1: Find Remixable Assets\nfrom story_protocol import Client\n\ndef find_remixable_assets(category, limit=10):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    remixable_assets = client.ip_asset_client.search_ip_assets(\n        filters={\n            'categories': [category],\n            'allows_derivatives': True\n        },\n        limit=limit\n    )\n    \n    print(f\"Found {remixable_assets.total} remixable assets in category '{category}'\")\n    \n    return remixable_assets.assets\n\n# Step 2: Create Derivative Work\nfrom pinata_web3 import PinataSDK\nimport os\n\ndef create_derivative_content(original_asset_id, derivative_metadata):\n    # Add attribution to metadata\n    enriched_metadata = {\n        **derivative_metadata,\n        'attribution': {\n            'originalAssetId': original_asset_id,\n            'relationship': 'derivative'\n        }\n    }\n    \n    # Upload to IPFS\n    pinata = PinataSDK(pinata_jwt=os.environ.get('PINATA_JWT'))\n    \n    result = pinata.upload.json(enriched_metadata)\n    ipfs_hash = result['IpfsHash']\n    \n    print('Derivative content created and uploaded to IPFS:', ipfs_hash)\n    \n    return ipfs_hash\n\n# Step 3: Register Relationship\ndef register_derivative_relationship(original_asset_id, derivative_asset_id):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    relationship = client.ip_asset_client.register_relationship(\n        parent_ip_asset_id=original_asset_id,\n        child_ip_asset_id=derivative_asset_id,\n        relation_type='DERIVATIVE',\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('Derivative relationship registered:', {\n        'Relationship ID': relationship.relationship_id,\n        'Transaction Hash': relationship.tx_hash\n    })\n    \n    return relationship.relationship_id\n\n# Step 4: Setup Attribution\ndef setup_attribution(original_asset_id, derivative_asset_id, attribution_text):\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    \n    attribution = client.attribution_client.set_attribution(\n        ip_asset_id=derivative_asset_id,\n        attributes_ip_asset_id=original_asset_id,\n        attribution_text=attribution_text,\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    print('Attribution configured:', {\n        'Attribution ID': attribution.attribution_id,\n        'Transaction Hash': attribution.tx_hash\n    })\n    \n    return attribution.attribution_id\n\n# Complete flow\ndef create_derivative_work(category, derivative_metadata, attribution_text):\n    # Step 1: Find remixable assets\n    remixable_assets = find_remixable_assets(category)\n    original_asset_id = remixable_assets[0].id  # Select first asset for this example\n    \n    # Step 2: Create derivative content\n    ipfs_hash = create_derivative_content(original_asset_id, derivative_metadata)\n    \n    # Create the derivative NFT\n    client = Client(api_key='mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8')\n    mint_result = client.ip_asset_client.mint_and_register_ip_asset(\n        to=os.environ.get('WALLET_ADDRESS'),\n        token_uri=f'ipfs://{ipfs_hash}',\n        tx_options={'wait_for_transaction': True}\n    )\n    \n    derivative_asset_id = mint_result.ip_asset_id\n    \n    # Step 3: Register relationship\n    relationship_id = register_derivative_relationship(original_asset_id, derivative_asset_id)\n    \n    # Step 4: Setup attribution\n    attribution_id = setup_attribution(original_asset_id, derivative_asset_id, attribution_text)\n    \n    return {\n        'original_asset_id': original_asset_id,\n        'derivative_asset_id': derivative_asset_id,\n        'ipfs_hash': ipfs_hash,\n        'relationship_id': relationship_id,\n        'attribution_id': attribution_id\n    }",
        "shell": "# This is a simplified example of the workflow\n# In practice, you would need to use multiple commands\n\n# Step 1: Find Remixable Assets\ncurl -X GET \"https://api.storyprotocol.xyz/v1/ip-assets/search?categories=art&allowsDerivatives=true&limit=10\" \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\"\n\n# Step 2: Create Derivative Work and Upload to IPFS\n# First, create a metadata file with attribution\ncat > derivative_metadata.json << EOL\n{\n  \"name\": \"My Derivative Work\",\n  \"description\": \"A derivative work based on original asset\",\n  \"image\": \"ipfs://YourImageHash...\",\n  \"attribution\": {\n    \"originalAssetId\": \"original-asset-id-from-step-1\",\n    \"relationship\": \"derivative\"\n  }\n}\nEOL\n\n# Upload to IPFS\ncurl -X POST https://api.pinata.cloud/pinning/pinJSONToIPFS \\\n  -H \"Authorization: Bearer your-pinata-jwt\" \\\n  -H \"Content-Type: application/json\" \\\n  -d @derivative_metadata.json\n\n# Mint the derivative NFT\ncurl -X POST https://api.storyprotocol.xyz/v1/ip-assets/mint-and-register \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"to\": \"your-wallet-address\",\n    \"tokenURI\": \"ipfs://your-ipfs-hash-from-previous-step\",\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'\n\n# Step 3: Register Relationship\ncurl -X POST https://api.storyprotocol.xyz/v1/ip-assets/relationships \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"parentIpAssetId\": \"original-asset-id-from-step-1\",\n    \"childIpAssetId\": \"derivative-asset-id-from-previous-step\",\n    \"relationType\": \"DERIVATIVE\",\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'\n\n# Step 4: Setup Attribution\ncurl -X POST https://api.storyprotocol.xyz/v1/attribution \\\n  -H \"Authorization: Bearer mcp_sk_live_51NxK8vKj2LmNpQrS5tYwX7ZcA9bD3fE6hJ8kM1nP4qR7sT0uV3wX5yZ8\" \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\n    \"ipAssetId\": \"derivative-asset-id-from-step-2\",\n    \"attributesIpAssetId\": \"original-asset-id-from-step-1\",\n    \"attributionText\": \"Based on original work by Creator XYZ\",\n    \"txOptions\": { \"waitForTransaction\": true }\n  }'"
      }
    }
  ]
}
